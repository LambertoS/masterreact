{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}


# returns the bytevector of the key, when it not exist it returns an empty string
func getBinaryValueFromScriptAccount (adr: Address, key: String) = {
    let data = match getBinaryValue(adr, key) {
        case a: ByteVector =>
            a
        case _ =>
            ""
    }
  data
}

# checks if the user is authenticated by checking the connection key (connection.Root.hash) on the script account and if it mathces the caller publicKey
func authUser (i: Invocation) = {
  if (i.caller == this) then
    true
  else
    # hash publicKey
    let callerPublicKeyHash = sha256(i.callerPublicKey);

    # get connection data from script account as hash
    # throws an exception when the key isnt found
    let scriptAccountPublicKeyHash = getBinaryValueFromScriptAccount(this, "connection.Root.hash");

    # check if they match
    if (scriptAccountPublicKeyHash == callerPublicKeyHash) then
      true
    else
      false
}

@Callable(i)
func saveListOnAccount(keys: List[String], values: List[String]) = {
  # check if caller is authorized
  let authenticated = authUser(i)

  if (authenticated) then
    func addStringEntry(accum: (List[StringEntry], Int), nextValue: String) = {
      let (result, j) = accum
      (result :+ StringEntry(keys[j], nextValue), j + 1)
    }

    let r = FOLD<900>(values, ([], 0), addStringEntry)
    r._1
  else
    throw("Account hat nicht die nötige Berechtigung für diese Aktion.")
}

@Callable(i)
func saveSingleKeyValueOnAccount(key: String, keyValue: String) = {
  # check if caller is authorized
  let authenticated = authUser(i)
  let refundAcc = Address(base58'3MtEvVnBT3Fqc8qHhG3C4ohsc1RZ8JDCn4w')

  if (authenticated) then
    strict r =  invoke(refundAcc, "refundWaves", [i.fee], [])
    [StringEntry(key, keyValue)]
  else
    throw("Account hat nicht die nötige Berechtigung für diese Aktion.")
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)






