{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# Piel
# Piel Plausibilitätsprüfung
# Piel Auftragsbestätigung
# Piel Lieferavisbestätigung
# for account role: customer
# v0.4

# todo desc
func getData (adr: Address, key: String) = {
    let data = match getString(adr, key) {
        case a: String =>
            a
        case _ =>
            ""
    }
    data
}

# returns the bytevector of the key, when it not exist it returns an empty string
func getBinaryValueFromScriptAccount (adr: Address, key: String) = {
    let data = match getBinaryValue(adr, key) {
        case a: ByteVector =>
            a
        case _ =>
            ""
    }
    data
}

# checks if the user is authenticated by checking the connection key (connection_Piel_hash) on the script account and if it matches the caller publicKey
func authUser (callerPublicKey: ByteVector) = {
# hash publicKey
    let callerPublicKeyHash = sha256(callerPublicKey);

    # get connection data from script account as hash
    # throws an exception when the key isnt found
    let scriptAccountPublicKeyHash = getBinaryValueFromScriptAccount(this, "connection_Piel_hash");

    # check if they match
    if (scriptAccountPublicKeyHash == callerPublicKeyHash) then
        true
    else
        false
}


@Callable(i)
func plausibilityCheck(positionKey: String, customerPublicKey: String) = {
    # positionKey: hash(debitor_artikelnr)_index_bestellmenge_timestamp_hash

    # customerPublicKey: there is now way to recieve the publickey of the dapp account apparrently
    # check if caller is authorized
    let authenticated = authUser(i.callerPublicKey)

    if (!authenticated) then
        throw("Account hat nicht die nötige Berechtigung für diese Aktion.")
    else
    # Piel
    let pielAddress = toBase58String(i.caller.bytes);

    # Data
    let positionKeyData = getData(this, positionKey);

    # Customer Position Key: hash(debitor_artikelnr)_index_bestellmenge_timestamp_hash
    # 0: hash, 1: index, 2: bestellmenge, 3: timestamp
    let positionKeySplit = split(positionKey, "_");
    let posNo = positionKeySplit[1];
    let positionQuantity = positionKeySplit[2];
    let timestamp = positionKeySplit[3];

    # Build Pricelist Quantity Key
    # key: Hash(debitor_artikelnr)_hash, value: staffel1_staffel2_staffel3
    let priceListForQuantitiesKey = positionKeySplit[0] + "_hash";
    let priceListForQuantitiesValue = getData(addressFromStringValue(pielAddress), priceListForQuantitiesKey);
    let priceListForQuantitiesValueToList = split(priceListForQuantitiesValue, "_");

    # Fold
    let positionQuantityInt = parseIntValue(positionQuantity);
    func find(accum: Int, nextValue: String) = {
    # Convert String to Int
        let priceListQuantityInt = parseIntValue(nextValue);
        # Check if position quantity is in range
        if (positionQuantityInt >= priceListQuantityInt) then
            priceListQuantityInt
        else
            accum
    }
    let result = FOLD<10>(priceListForQuantitiesValueToList, 0, find)

    # Build Key (Piel): Hash(debitor_artikelnr)_staffelmenge
    let priceListKey = positionKeySplit[0] + "_" + toString(result) + "_hash";
    # Get Data from piel
    let data = getData(addressFromStringValue(pielAddress), priceListKey)

    if (data == positionKeyData) then
        [
            StringEntry(customerPublicKey + "_pos_" + posNo + "_statusCode_" + timestamp, "success")
        ]
    else
        [
            StringEntry(customerPublicKey + "_pos_" + posNo + "_statusCode_" + timestamp, "error")
        ]
}

@Callable(i)
func saveListOnAccount(keys: List[String], values: List[String]) = {
    # check if caller is authorized
    let authenticated = authUser(i.callerPublicKey)

    if (authenticated) then
        func addStringEntry(accum: (List[StringEntry], Int), nextValue: String) = {
            let (result, j) = accum
            (result :+ StringEntry(keys[j], nextValue), j + 1)
        }

        let r = FOLD<900>(values, ([], 0), addStringEntry)
        r._1
    else
        throw("Account hat nicht die nötige Berechtigung für diese Aktion.")
}

@Callable(i)
func saveSingleKeyValueOnAccount(key: String, keyValue: String) = {
# check if caller is authorized
    let authenticated = authUser(i.callerPublicKey)

    if (authenticated) then
        [StringEntry(key, keyValue)]
    else
        throw("Account hat nicht die nötige Berechtigung für diese Aktion.")
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)